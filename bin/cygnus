#!/usr/bin/env ruby
# ----------------------------------------------------------------------------- #
#         File: cygnus
#  Description: A class that displays text using a pad.
#         The motivation for this is to put formatted text and not care about truncating and 
#         stuff. Also, there will be only one write, not each time scrolling happens.
#         I found textview code for repaint being more complex than required.
#       Author: rkumar http://github.com/rkumar/mancurses/
#         Date: 2011-11-09 - 16:59
#      License: Same as Ruby's License (http://www.ruby-lang.org/LICENSE.txt)
#  Last update: 2013-03-10 22:36
#
#  == CHANGES
#  == BUGS
#     _ single quote not triggering or finding event, although it is bound.
#     _ when changing dirs , old crow is left, should be first, or previously used.
#     _ unable to display a file with very long lines.
#
#  == TODO 
#
#     _ use same keys as cetus for parent pop etc , . ' etc maybe even backtick for menu
#     _ goto_dir
#     _ jump to single pane and back.
#
#
#     when moving right, also don't pan straight away
#     x add mappings and process key in handle_keys and other widget things
#     x user can put text or list
#     . handle putting data again and overwriting existing
#     . formatted text
#     x search and other features
#     - can pad movement and other ops be abstracted into module for reuse
#     / get scrolling like in vim (C-f e y b d)
#     - alert issue of leaving a blank is poss due to using prefresh i/o copywin
#
#   == TODO 2013-03-07 - 20:34 
#   _ key bindings not showing up -- bind properly
#   _ F1 screen leaves everything blank, so does bindings
# ----------------------------------------------------------------------------- #
#
require 'rbcurse'
require 'cygnus/textpad'
require 'rbcurse/core/util/app'
require 'fileutils'


  class DirRenderer
    def render pad, lineno, text
      bg = :black
      fg = :white
      att = NORMAL
      cp = $datacolor
      if File.directory? text
        fg = :blue
        att = BOLD
        text << "/"
        cp = get_color($datacolor, fg, bg)
      elsif File.symlink? text
        fg = :magenta
        #text << "->"
        text = text + "->"
        cp = get_color($datacolor, fg, bg)
      elsif File.executable? text
        fg = :yellow
        #text << "*"
        text = text + "*"
        cp = get_color($datacolor, fg, bg)
      elsif text =~ /(~|swp)$/
        fg = :blue
        #att = BOLD
        cp = get_color($datacolor, fg, bg)
      else
      end
      FFI::NCurses.wattron(pad,FFI::NCurses.COLOR_PAIR(cp) | att)
      FFI::NCurses.mvwaddstr(pad, lineno, 0, text)
      FFI::NCurses.wattroff(pad,FFI::NCurses.COLOR_PAIR(cp) | att)

    end # def
  end # class

  App.new do
    $bookmarks = {}
    $cursor = 0
    ## accept a character to save this dir as a bookmark
    def create_bookmark
      ch = get_string "Enter A to Z or 0-9 for bookmark: "
      return if ch.nil? || ch == ""
      #ch = @window.get_char
      if ch =~ /^[0-9A-Z]$/
        #$bookmarks[ch] = "#{Dir.pwd}:#{$cursor}"
        $bookmarks[ch] = $current_file
        $modified = true
      else
        alert "Bookmark must be upper-case character or number."
      end
    end
    def goto_bookmark ch=nil
      unless ch
        #ch = get_string "Enter bookmark char: "
        ch = @window.getchar().chr
        return if ch.nil? || ch == ""
      end
      if ch =~ /^[0-9A-Z]$/
        d = $bookmarks[ch]
        if d
          filename = File.basename(d)
          dir = File.dirname(d)
          change_dir dir, filename
        else
          alert "#{ch} not a bookmark"
        end
      else
        # goto_entry_starting_with ch
        file_starting_with ch
      end
    end
    def file_starting_with fc
      ix = return_next_match(method(:file_matching?), "^#{fc}")
      if ix
        #alert "Got match for #{fc} : #{ix}"
        $view.goto_line ix
      else
        alert "Got no match for #{fc}"
      end
    end
    def file_matching? file, patt
      # WARN crashes with [ or other characters
      file =~ /#{patt}/
    end
    def filelist
      tv = @form.by_name["dirlist"]
      return tv.content()
    end

    ## generic method to take cursor to next position for a given condition
    def return_next_match binding, *args
      first = nil
      ix = 0
      filelist().each_with_index do |elem,ii|
        if binding.call(elem.to_s, *args)
          first ||= ii
          if ii > $cursor 
            ix = ii
            break
          end
        end
      end
      return first if ix == 0
      return ix
    end
    @dir_stack = []
    def change_dir dir, filename=nil
      @dir_stack << Dir.pwd unless @dir_stack.include? Dir.pwd
      FileUtils.cd dir
      display_dir
      # TODO also position cursor on file if passed
      display_file filename if filename
    end
    def display_file filename
      tv = @form.by_name["tv"]
      tv.title = filename
      tv.filename(filename)
      tv.text(get_file_contents(filename))
      $viewed_file = filename
    end
    def display_dir
      p = @form.by_name["dirlist"]
      p.title(File.basename(Dir.pwd))
      text = get_dirs
      p.text(text)
    end
    def get_dirs
      text = Dir.entries "."
      text.delete_at 0
      return text
    end
    def goto_parent_dir
      change_dir ".."
    end
    def pop_dir
      d = @dir_stack.pop
      return unless d
      FileUtils.cd d
      display_dir
    end
    def goto_dir
      dir = get_string "Enter directory to go to "
      return if dir.nil? || dir == ""
      dir = File.expand_path dir
      if File.directory? dir
        change_dir dir
      else
        alert "#{dir} not a directory"
      end
    end
    def filetype f
      text = `file #{f}`
      if text.include? "text"
            $log.debug "XXX:  html file #{text}"
        return :html if text.include?("HTML")
        return :text
      elsif text =~ /(archive|zip)/
        return :zip
      else
        return :unknown
      end
    end
    def get_file_contents f
      ft = filetype f
      $log.debug "XXX:  html filetype #{ft}"
      case ft
      when :text
        return File.open(f,"r").readlines
      when :html
        $log.debug "XXX:  html inside filetype #{ft}"
          t = `html2text #{f} 2>&1`.split "\n"
        $log.debug "XXX:  html after running html2text #{t.first}"
          if t.first.include? "command not found"
            $log.debug "XXX:  html command not found #{t}"
            return File.open(f,"r").readlines
          end
          return t
      when :zip
        return `tar ztvf #{f}`.split("\n")
      else
        return ["unknown type", `file #{f}`]
      end
    end
    @form.bind_key(?q, "quit: ") { throw :close }
    @form.bind_key(?,, "goto_parent_dir") { goto_parent_dir }
    @form.bind_key(?., "pop_dir") { pop_dir }
    @form.bind_key(?+, "goto_dir") { goto_dir }
    @form.bind_key(?m, "create_bookmark") { create_bookmark }
    @form.bind_key(?', "goto_bookmark") { goto_bookmark }
    w = 20
    w2 = FFI::NCurses.COLS-w-1
    title = File.basename(Dir.pwd)
    
    p = Cygnus::TextPad.new @form, :height => FFI::NCurses.LINES-1, :width => w, :row => 0, :col => 0 , :title => title, :name => "dirlist"
    p.renderer DirRenderer.new
    $view = p

    p.bind(:PRESS) do |aev|
      o = aev.source
      filename = aev.text
      if File.directory? filename
        change_dir filename
      else
        display_file filename
      end
    end
    p.bind(:ENTER_ROW) do |aev|
      filename = aev.text
      $current_file = "#{Dir.pwd}/#{filename}"
      st = File.stat(filename)
      $cursor = aev.current_index
      $message.value = "%20s %10s %s" % [ st.mtime, st.size, filename ]
    end

    text = get_dirs
    p.text(text)

    t = Cygnus::TextPad.new @form, :height => FFI::NCurses.LINES-1, :width => w2+2, :row => 0, :col => w-1 , :title => " ruby ", :name => "tv"
    $tv = t
    t.bind(:PRESS) do |aev|
      alert "Press got #{aev.curpos}, #{aev.current_index}, #{aev.text}"
    end

    $message = Variable.new
    $message.value = "## File Stat Area ##"
    @status_line = status_line :row => Ncurses.LINES-1

    @status_line.command {
      "q Quit | ? Keys | %40s" % [$message.value]
    }
  end
