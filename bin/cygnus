#!/usr/bin/env ruby
# ----------------------------------------------------------------------------- #
#         File: cygnus
#  Description: A class that displays text using a pad.
#         The motivation for this is to put formatted text and not care about truncating and 
#         stuff. Also, there will be only one write, not each time scrolling happens.
#         I found textview code for repaint being more complex than required.
#       Author: rkumar http://github.com/rkumar/mancurses/
#         Date: 2011-11-09 - 16:59
#      License: Same as Ruby's License (http://www.ruby-lang.org/LICENSE.txt)
#  Last update: 2013-03-14 14:45
#
#  == CHANGES
#  == BUGS
#     x when changing dirs , old crow is left, should be first, or previously used.
#       when form triggers a key then bounds check not run. form keys are a pain with pad
#       anything happening outside of here
#     x unable to display a file with very long lines. - these were dos format with CR in it.
#
#  == TODO 
#
#     _ columnate, fix alignment with truncating, 
#       _ paging when more than pagesize * cols.
#       _ need to get the keys, in fact make this the first thing on top.
#         such as parent. pop. + etc. bookmark etc
#     _ work on common file, so functionality of cetus can be shared easily
#     x use same keys as cetus for parent pop etc , . ' etc maybe even backtick for menu
#     _ jump to single pane and back.
#     _ save bookmarks
#     x view files from z and viminfo
#
#
#     when moving right, also don't pan straight away
#     x add mappings and process key in handle_keys and other widget things
#     x user can put text or list
#     . handle putting data again and overwriting existing
#     . formatted text
#     x search and other features
#     - can pad movement and other ops be abstracted into module for reuse
#     / get scrolling like in vim (C-f e y b d)
#     - alert issue of leaving a blank is poss due to using prefresh i/o copywin
#
#   == TODO 2013-03-07 - 20:34 
#   _ key bindings not showing up -- bind properly
#   _ F1 screen leaves everything blank, so does bindings
# ----------------------------------------------------------------------------- #
#
require 'rbcurse'
require 'cygnus'
require 'cygnus/textpad'
require 'rbcurse/core/util/app'
require 'fileutils'
include Cygnus


  class DirRenderer
    def render pad, lineno, text
      bg = :black
      fg = :white
      att = NORMAL
      cp = $datacolor
      if File.directory? text
        fg = :blue
        att = BOLD
        text << "/"
        cp = get_color($datacolor, fg, bg)
      elsif File.symlink? text
        fg = :magenta
        #text << "->"
        text = text + "->"
        cp = get_color($datacolor, fg, bg)
      elsif File.executable? text
        fg = :yellow
        #text << "*"
        text = text + "*"
        cp = get_color($datacolor, fg, bg)
      elsif text =~ /(~|swp)$/
        fg = :blue
        #att = BOLD
        cp = get_color($datacolor, fg, bg)
      else
      end
      FFI::NCurses.wattron(pad,FFI::NCurses.COLOR_PAIR(cp) | att)
      FFI::NCurses.mvwaddstr(pad, lineno, 0, text)
      FFI::NCurses.wattroff(pad,FFI::NCurses.COLOR_PAIR(cp) | att)

    end # def
  end # class
  def padpopuplist list, config={}, &block
    raise ArgumentError, "Nil list received by popuplist" unless list
    require 'cygnus/textpad'

    max_visible_items = config[:max_visible_items]
    row = config[:row] || 5
    col = config[:col] || 5
    relative_to = config[:relative_to]
    if relative_to
      layout = relative_to.form.window.layout
      row += layout[:top]
      col += layout[:left]
    end
    config.delete :relative_to
    longest = list.max_by(&:length)
    width = config[:width] || longest.size()+2 # borders take 2
    if config[:title]
      width = config[:title].size + 2 if width < config[:title].size
    end
    height = config[:height]
    height ||= [max_visible_items || 10+2, list.length+2].min 
    #layout(1+height, width+4, row, col) 
    layout = { :height => 0+height, :width => 0+width, :top => row, :left => col } 
    window = VER::Window.new(layout)
    form = RubyCurses::Form.new window

    listconfig = config[:listconfig] || {}
    listconfig[:list] = list
    listconfig[:width] = width
    listconfig[:height] = height
    #listconfig[:selection_mode] ||= :single
    listconfig.merge!(config)
    listconfig.delete(:row); 
    listconfig.delete(:col); 
    # trying to pass populists block to listbox
    #lb = RubyCurses::List.new form, listconfig, &block
    lb = Cygnus::TextPad.new form, listconfig, &block
    #lb = Cygnus::TextPad.new form, :height => height, :width => width, :row => 0, :col => 0 , :title => "A title", :name => "popup"
    lb.text(list)
    #
    window.bkgd(Ncurses.COLOR_PAIR($reversecolor));
    form.repaint
    Ncurses::Panel.update_panels
    begin
      while((ch = window.getchar()) != 999 )
        case ch
        when -1
          next
        when ?\C-q.getbyte(0)
          break
        else
          lb.handle_key ch
          form.repaint
          if ch == 13 || ch == 10
            return lb.current_index #if lb.selection_mode != :multiple

#            x = lb.selected_indices
            return x if x
            x = lb.current_index unless x
            return [x]
            # if multiple selection, then return list of selected_indices and don't catch 32
          ##elsif ch == 32      # if single selection
            return lb.current_index #if lb.selection_mode != :multiple
          end
          #yield ch if block_given?
        end
      end
    ensure
      window.destroy  
    end
    return nil
  end
  def main_menu
    h = { 
      :a => :ack,
      "/" => :ffind,
      :l => :locate,
      :v => :viminfo,
      :z => :z_interface,
      :d => :child_dirs,
      :r => :recent_files,
      :t => :dirtree,
      "4" => :tree,
      :s => :sort_menu, 
      :F => :filter_menu,
      :c => :command_menu ,
      :B => :bindkey_ext_command,
      :M => :newdir,
      "%" => :newfile,
      :X => :file_navigator,
      :x => :extras
    }
    ch, binding = menu "Main Menu", h
    #alert "Menu got #{ch}, #{binding}" if ch
  end
  ## 
  #
  #  make one which takes a single key and returns that key
  #  Then call that from menu, indexed list etc, so we are not copying
  #  that same thing over and over for tiny variations.
  #
  def menu title, hash, config={}, &block
    raise ArgumentError, "Nil hash received by menu" unless hash
    list = []
    hash.each_pair { |k, v| list << "   #[fg=yellow, bold] #{k} #[/end]    #[fg=green] #{v} #[/end]" }
  #  s="#[fg=green]hello there#[fg=yellow, bg=black, dim]"
    config[:title] = title
    ch = padpopup list, config, &block
    return unless ch
    if ch.size > 1
      # could be a string due to pressing enter
      # but what if we format into multiple columns
      ch = ch.strip[0]
    end

    binding = hash[ch]
    binding = hash[ch.to_sym] unless binding
    if binding
      if respond_to?(binding, true)
        send(binding)
      end
    end
    return ch, binding
  end

  # pops up a list, taking a single key and returning if it is in range of 33 and 126
  def padpopup list, config={}, &block
    require 'cygnus/textpad'
    max_visible_items = config[:max_visible_items]
    row = config[:row] || 5
    col = config[:col] || 5
    relative_to = config[:relative_to]
    if relative_to
      layout = relative_to.form.window.layout
      row += layout[:top]
      col += layout[:left]
    end
    config.delete :relative_to
    #longest = list.max_by(&:length)
    width = config[:width] || 60
    if config[:title]
      width = config[:title].size + 2 if width < config[:title].size
    end
    height = config[:height]
    height ||= [max_visible_items || 25, list.length+2].min 
    #layout(1+height, width+4, row, col) 
    layout = { :height => 0+height, :width => 0+width, :top => row, :left => col } 
    window = VER::Window.new(layout)
    form = RubyCurses::Form.new window

    ## added 2013-03-13 - 18:07 so caller can be more specific on what is to be returned
    valid_keys_int = config.delete :valid_keys_int
    valid_keys_char = config.delete :valid_keys_char

    listconfig = config[:listconfig] || {}
    #listconfig[:list] = list
    listconfig[:width] = width
    listconfig[:height] = height
    #listconfig[:selection_mode] ||= :single
    listconfig.merge!(config)
    listconfig.delete(:row); 
    listconfig.delete(:col); 
    # trying to pass populists block to listbox
    #lb = RubyCurses::List.new form, listconfig, &block
    lb = Cygnus::TextPad.new form, listconfig, &block
    #lb = Cygnus::TextPad.new form, :height => height, :width => width, :row => 0, :col => 0 , :title => "A title", :name => "popup"
    #lb.text(list)
    ## TODO FIXME hardocoding tmux format
    lb.formatted_text(list, :tmux)
    #
    window.bkgd(Ncurses.COLOR_PAIR($reversecolor));
    form.repaint
    Ncurses::Panel.update_panels
    if valid_keys_int.nil? && valid_keys_char.nil?
      valid_keys_int = (32..126)
    end

    begin
      while((ch = window.getchar()) != 999 )

        # if a char range or array has been sent, check if the key is in it and send back
        # else just stay here
        if valid_keys_char
          if ch > 32 && ch < 127
            chr = ch.chr
            return chr if valid_keys_char.include? chr
          end
        end

        # if the user specified an array or range of ints check against that
        # therwise use the range of 33 .. 126
        return ch.chr if valid_keys_int.include? ch

        case ch
        when -1
          alert "does it really come here? -1 XXXXXXX"
          next
        when ?\C-q.getbyte(0)
          break
        else
          #if ch > 32 && ch < 127
            #ch = ch.chr
            #return ch
          #end
          if ch == 13 || ch == 10
            s = lb.current_value.to_s # .strip #if lb.selection_mode != :multiple
            return s
            #ch = s[0].ord
          end
          # close if escape or double escape
          if ch == 27 || ch == 2727
            return nil
          end
          lb.handle_key ch
          form.repaint
        end
      end
    ensure
      window.destroy  
    end
    return nil
  end
  # pops up a list, taking a single key and returning if it is in range of 33 and 126
  def full_indexed_list dir=Dir.pwd, config={}, &block
    require 'cygnus/textpad'
    max_visible_items = config[:max_visible_items]
    row = config[:row] || 0
    col = config[:col] || 0
    relative_to = config[:relative_to]
    if relative_to
      layout = relative_to.form.window.layout
      row += layout[:top]
      col += layout[:left]
    end
    config.delete :relative_to
    #longest = list.max_by(&:length)
    width = config[:width] || FFI::NCurses.COLS
    if config[:title]
      width = config[:title].size + 2 if width < config[:title].size
    end
    height = config[:height]
    #height ||= [max_visible_items || 25, list.length+2].min 
    height ||= FFI::NCurses.LINES - 1
    #layout(1+height, width+4, row, col) 
    layout = { :height => 0+height, :width => 0+width, :top => row, :left => col } 
    window = VER::Window.new(layout)
    form = RubyCurses::Form.new window

    ## added 2013-03-13 - 18:07 so caller can be more specific on what is to be returned
    valid_keys_int = config.delete :valid_keys_int
    valid_keys_char = config.delete :valid_keys_char

    
    listconfig = config[:listconfig] || {}
    #listconfig[:list] = list
    listconfig[:width] = width
    listconfig[:height] = height
    #listconfig[:selection_mode] ||= :single
    listconfig.merge!(config)
    listconfig.delete(:row); 
    listconfig.delete(:col); 
    list = get_file_list(dir)
    #alist = index_this_list list
    #alist = columnate alist, $grows
    # NOTE XXX we are supposed to page the list with space, using pagelist
    alist = columnate_with_indexing list, $grows
    # trying to pass populists block to listbox
    #lb = RubyCurses::List.new form, listconfig, &block
    lb = Cygnus::TextPad.new form, listconfig, &block
    #lb.text(list)
    ## TODO FIXME hardocoding tmux format
    lb.formatted_text(alist, :tmux)
    #
    window.bkgd(Ncurses.COLOR_PAIR($reversecolor));
    form.repaint
    Ncurses::Panel.update_panels

    begin
      while((ch = window.getchar()) != 999 )

        # if a char range or array has been sent, check if the key is in it and send back
        # else just stay here
          if ch > 32 && ch < 127
            chr = ch.chr
            ix = get_index chr
            if ix
              file = list[ix]
              if file
                file = File.expand_path file
                if File.directory? file
                  FileUtils.chdir file
                  list = get_file_list
                  #alist = index_this_list list
                  alist = columnate_with_indexing list, $grows
                  lb.formatted_text(alist, :tmux)
                  lb.title = Dir.pwd
                  lb.padrefresh
                  form.repaint
                  next
                elsif File.file? file
                  return file
                else
                  alert "Neither file not directory: (#{file})"
                  $log.warn "XXXXX: FILE Neither file not directory: (#{file})"
                end
              end
            else
            end
            next
          end


        case ch
        when -1
          alert "does it really come here? -1 XXXXXXX"
          next
        when ?\C-q.getbyte(0)
          break
        else
          #if ch > 32 && ch < 127
            #ch = ch.chr
            #return ch
          #end
          if ch == 13 || ch == 10
            return Dir.pwd
            s = lb.current_value.to_s # .strip #if lb.selection_mode != :multiple
            return s
            #ch = s[0].ord
          end
          # close if escape or double escape
          if ch == 27 || ch == 2727
            return nil
          end
          lb.handle_key ch
          form.repaint
        end
      end
    ensure
      window.destroy  
    end
    return nil
  end
  def get_index key, vsz=999
    # FIXME all this stuff about another key has to happen in the popup, not here
    i = $IDX.index(key)
    return i+$stact if i
    #sz = $IDX.size
    zch = nil
    if vsz > 25
      if key == "z" || key == "Z"
        #print key
        zch = get_char
        #print zch
        i = $IDX.index("#{key}#{zch}")
        return i+$stact if i
      end
    end
    return nil
  end
  def get_shortcut ix
    $stact = 0
    return "<" if ix < $stact
    ix -= $stact
    i = $IDX[ix]
    return i if i
    return "->"
  end
  def index_this_list list
    alist = []
    list.each_with_index { |v, ix| 
      k = get_shortcut ix
      #alist << " #[fg=yellow, bold] #{k} #[end] #[fg=green]#{v}#[end]" 
      # above gets truncated by columnate and results in errors in colorparsers etc
      alist << " #{k} #{v}" 
    }
    return alist
  end

  $IDX=('a'..'y').to_a
  $IDX.concat ('za'..'zz').to_a
  $IDX.concat ('Za'..'Zz').to_a
  $IDX.concat ('ZA'..'ZZ').to_a
  def indexed_list title, list, config={}, &block
    raise ArgumentError, "Nil list received by indexed_list" unless list
    alist = index_this_list list
    longest = list.max_by(&:length)
  #  s="#[fg=green]hello there#[fg=yellow, bg=black, dim]"
    config[:title] = title
    # if width is greater than size of screen then padfresh will return -1 and nothing will print
    config[:width] = [ longest.size() + 10, FFI::NCurses.COLS - 1 ].min
    config[:row] = config[:col] = 0
    ch = padpopup alist, config, &block
    return unless ch
    if ch.size > 1
      # could be a string due to pressing enter
      # but what if we format into multiple columns
      ch = ch.strip[0]
    end
    ch = get_index ch
    return nil unless ch

    return list[ch]
  end

  # This displays the list provided with alpha indexing
  # The user types one char to select the file which is then displayed
  # using your specific open file -- which could open in an ncurses window 
  # or in vim or some pager in your CLI program.
  #
  # this is a specfic functionthat has to be implemented separately by CLI and ncurses
  # programs
  def show_list
    file = indexed_list $title || "Some Files", $files
    if file 
      open_file file
    end
  end


  App.new do
    $bookmarks = {}
    $cursor = 0
    def file_navigator
      file = full_indexed_list
      open_file file if file
    end
    ## accept a character to save this dir as a bookmark
    # Here we are saving a file as a bookmark, not a dir
    # The config file currently has a dir
    def create_bookmark
      ch = get_string "Enter A to Z or 0-9 for bookmark: "
      return if ch.nil? || ch == ""
      #ch = @window.get_char
      if ch =~ /^[0-9A-Z]$/
        #$bookmarks[ch] = "#{Dir.pwd}:#{$cursor}"
        $bookmarks[ch] = $current_file
        $modified = true
      else
        alert "Bookmark must be upper-case character or number."
      end
    end
    def goto_bookmark ch=nil
      unless ch
        #ch = get_string "Enter bookmark char: "
        ch = @window.getchar().chr
        return if ch.nil? || ch == ""
      end
      if ch =~ /^[0-9A-Z]$/
        d = $bookmarks[ch]
        if d
          if File.file? d
            filename = File.basename(d)
            dir = File.dirname(d)
          else
            dir = d
            filename = nil
          end
          change_dir dir, filename
        else
          alert "#{ch} not a bookmark"
        end
      else
        # goto_entry_starting_with ch
        file_starting_with ch
      end
    end
    def file_starting_with fc
      ix = return_next_match(method(:file_matching?), "^#{fc}")
      if ix
        #alert "Got match for #{fc} : #{ix}"
        $view.goto_line ix
      else
        alert "Got no match for #{fc}"
      end
    end
    def file_matching? file, patt
      # WARN crashes with [ or other characters
      file =~ /#{patt}/
    end
    def filelist
      tv = @form.by_name["dirlist"]
      return tv.content()
    end

    ## generic method to take cursor to next position for a given condition
    def return_next_match binding, *args
      first = nil
      ix = 0
      filelist().each_with_index do |elem,ii|
        if binding.call(elem.to_s, *args)
          first ||= ii
          if ii > $cursor 
            ix = ii
            break
          end
        end
      end
      return first if ix == 0
      return ix
    end
    @dir_stack = []
    def change_dir dir, filename=nil
      @dir_stack << Dir.pwd unless @dir_stack.include? Dir.pwd
      FileUtils.cd dir
      display_dir
      # TODO also position cursor on file if passed
      display_file filename 
    end
    def display_file filename
      if filename && File.exists?(filename) && !File.directory?(filename)
      else
        return
      end
      tv = @form.by_name["tv"]
      tv.title = filename
      tv.filename(filename)
      tv.text(get_file_contents(filename))
      $viewed_file = filename
    end
    def display_dir
      p = @form.by_name["dirlist"]
      p.title(File.basename(Dir.pwd))
      text = get_file_list
      p.text(text)
    end
    def get_file_list dir="."
      list = Dir.entries dir
      list.delete_at 0
      list.collect! do |e|
        if File.directory? e
          e << "/"
        else
          e
        end
      end
      return list
    end
    def pop_dir
      d = @dir_stack.pop
      return unless d
      FileUtils.cd d
      display_dir
    end
    def filetype f
      text = `file #{f}`
      if text.include? "text"
        return :html if text.include?("HTML")
        return :text
      elsif text =~ /(archive|zip)/
        return :zip
      else
        return :unknown
      end
    end
    def get_file_contents f
      ft = filetype f
      case ft
      when :text
        lines = File.open(f,"r").readlines
        # check line 1
        if lines.first =~ /[\t\r]/
          $log.debug "Found carriage returns (or tabs) in #{f}. stripping ..."
          lines = lines.collect do |line|
            line.gsub(/[\r\t]/,"")
          end
        end
        return lines
      when :html
          t = `html2text #{f} 2>&1`.split "\n"
          if t.first.include? "command not found"
            return File.open(f,"r").readlines
          end
          return t
      when :zip
        return `tar ztvf #{f}`.split("\n")
      else
        return ["unknown type", `file #{f}`]
      end
    end
    def show
      list = get_file_list
      ix = padpopuplist list, :title => "Files", :bgcolor => :blue, :color => :white
      return unless ix
      open_file list[ix]
      #alert "Got #{list[ix]}" if ix
    end
    def open_file filename
      filename = File.expand_path filename
      if File.directory? filename
        change_dir filename
      else
        display_file filename
      end
    end
    config_read
    @form.bind_key(?q, "quit: ") { throw :close }
    @form.bind_key(?,, "goto_parent_dir") { goto_parent_dir }
    @form.bind_key(?., "pop_dir") { pop_dir }
    @form.bind_key(?+, "goto_dir") { goto_dir }
    @form.bind_key(?m, "create_bookmark") { create_bookmark }
    @form.bind_key(?f, "file_navigator") { file_navigator }
    @form.bind_key(?', "goto_bookmark") { goto_bookmark }
    @form.bind_key(?\M-b, "select_bookmark") { select_bookmark }
    @form.bind_key(?\M-c, "show") { show }
    @form.bind_key(?`, "main_menu") { main_menu }
    w = 20
    w2 = FFI::NCurses.COLS-w-1
    title = File.basename(Dir.pwd)
    
    p = Cygnus::TextPad.new @form, :height => FFI::NCurses.LINES-1, :width => w-0, :row => 0, :col => 0 , :title => title, :name => "dirlist"
    p.renderer DirRenderer.new
    $view = p

    p.bind(:PRESS) do |aev|
      o = aev.source
      filename = aev.text
      open_file filename
    end
    p.bind(:ENTER_ROW) do |aev|
      filename = aev.text
      $current_file = "#{Dir.pwd}/#{filename}"
      st = File.stat(filename)
      $cursor = aev.current_index
      $message.value = "%20s %10s %s" % [ st.mtime, st.size, filename ]
    end

    text = get_file_list
    p.text(text)

    t = Cygnus::TextPad.new @form, :height => FFI::NCurses.LINES-1, :width => w2+2, :row => 0, :col => w-1 , :title => " ruby ", :name => "tv"
    t.renderer Cygnus::DefaultFileRenderer.new
    $tv = t
    t.bind(:PRESS) do |aev|
      alert "Press got #{aev.curpos}, #{aev.current_index}, #{aev.text}"
    end

    $message = Variable.new
    $message.value = "## File Stat Area ##"
    @status_line = status_line :row => Ncurses.LINES-1

    @status_line.command {
      "cygnus | q Quit | ? Keys | ` Menu  | %40s" % [$message.value]
    }
  end
